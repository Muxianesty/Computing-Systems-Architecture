[Литвинов Михаил Юрьевич, группа БПИ203, вариант по списку: 97]

В проекте используются:
6 модулей реализации

Общий размер исходных текстов: 16,3 КБ
Используемая вычислительная система: ОС Windows 10 x64 со сборкой в компиляторе MinGW x64 + тестирование на Windows Subsystem for Linux (WSL)


Основная информация(пункт I):

Задание 3: разработать программу, оформленную в виде консольного приложения, позволяющую считывать несколькими способами входные данные 
об абстрактном представлении конкретных сущностей (далее - "Артефакты и образованные от них альтернативы"), выбор которых диктуется 
выбранным вариантом задания, в виде упорядоченного контейнера с дальнейшим применением к нему конкретного алгоритма обработки данных, 
который также диктуется выбранным вариантом задания.

Особенностью текущего задания(номер 3) является использование языка программирования, поддерживающего архитектуру динамической типизации (Python 3).
В данной реализации используется объектно-ориентированный подход.

Текущая реализация предусматривает считывание входных данных о контейнере альтернатив одним из двух способов:
из указанного файла (посредством передачи пути к нему в качестве одного из параметров программы) или
посредством генерации псевдо-случайных значений. Формат входных данных будет описан далее.

Учитывая текущий вариант задания (13), в качестве основного артефакта используется класс Plant("Растение"), обладающий
полем имени (без учета вспомогательных полей внутри самой реализации абстрактного типа данных). В качестве базовых альтернатив
рассматриваются сущности Bush("Кустарник", обладающая полем месяца цветения, выраженным с помощью перечислимого типа BlossomMonth), 
Flower("Цветок", обладающая полем типом самого растения, выраженным с помощью перечислимого типа FlowerType) и Tree("Дерево", обладающая
полем возраста дерева, выраженным с помощью типа int). 
Каждая из альтернатив имеет возможность использования функции подсчета отношения количества гласных в имени к длине самого имени, тем самым
позволяя получать ключ для дальнейшей сортировки элементов. Типом сортировки, определяемым вариантом задания, в данном случае является
Binary Insertion (функция 7 из файла tasks.pdf): реализация сортировки вставкой, в которой поиск позиции для установки нового поступившего
на обработку элемента осуществляется посредством метода двоичного поиска.


Формат входных данных(пункт II):

На вход программе подается четыре аргумента (пять с учетом пути до самого исполняемого файла - main.py)
причем первый является ключом, определяющим, будет ли использоваться генерация псевдо-случайных значений для данных о растениях или будет
использоваться ввод из файла. Следующий аргумент определяется на основании предыдущего: если используется генерация псевдо-случайных
значений, то аргументом будет количество растений, которое необходимо сгенерировать, в противном случае аргументом будет путь к файлу,
из которого будет производиться считывание значений. Последними двумя параметрами всегда являются два пути к файлам, в которые будут записываться
данные о растениях в контейнере до и после применения к ним сортировки соответственно. 

Итоговые шаблоны входных данных:
"<path>\main.py -r <quantity> <first output txt-file path> <second output txt-file path>"
"<path>\main.py -f <first input txt-file> <first output txt-file path> <second output txt-file path>"
где "-r" и "-f" - флаги, обозначающие генерацию псевдо-случайных значений и считывание из файла соответственно.


Необходимо также учитывать формат ввода данных из файла:

В файле все данные должны иметь один пробел в качестве разделителя. В самом начале файла должно быть написано количество всех считываемых растений
(в случае, если будет считано некорректное значение (отрицательное число или число более 10000, то в качестве размера будет использоваться число 0).
Удобнее всего представлять информацию о каждом растении на отдельной строке: сначала указывается число от 1 до 3 (в противном случае используется
приведение к этому диапазону через деление по модулю 3), указывающее на конкретный тип растения (1 - Куст, 2 - Цветок, 3 - Дерево).
После типа растения всегда должно идти его имя, длина которого не превышает 20 символов (в противном случае нельзя предсказать, какое значение
будет считано далее, но ошибка выполнения программы возникнуть не должна). Последний параметр считывается в зависимости от типа рассматриваемого
растения: для куста указывается номер месяца его цветения (1 - Январь, 2 - Февраль, ..., 12 - Декабрь), для цветка указывается число от 1 до 3 - 
номер его типа (1 - Домашний, 2 - Садовый, 3 - Дикорастущий), для дерева указывается его возраст (однако при псевдо-случайной генерации в целях
безопасности используются значения от 1 до 500), причем во всех вариантах ведется обработка случаев ввода отрицательных чисел и/или значений,
выходящих за пределы допустимого диапазона. 
Пример:
5
1 ae 3
2 test 1
3 aaaaaaaaaa 200
2 abcdefg 3
1 tre 1

подразумевает

Куст ae, цветет в марте
Цветок test, домашний
Дерево aaaaaaaaaa, 200 год
Цветок abcdefg, дикий
Куст tre, цветет в январе


Сравнение текущих полученных результатов с предыдущими(пункт III):

заметим, что при сравнительно большом количестве входных данных (примерно начиная с n = 500, поскольку при n = 1000 разница во времени исполнения программы уже
составляет 4 раза) текущая реализация выполняет ту же задачу, что и обе предыдущие реализации на C++, за гораздо большее время. Я могу предположить, что причина этого 
заключается в динамической проверке типов в момент выполнения самой программы: например, в текущей реализации в конструкторе любой из альтернатив присутствует список
"params" - контейнер, содержащий данные о создаваемом растении, представленные в строковом виде, но перед выполнением программы данное свойство не проверяется, поэтому
в тех же конструкторах, чтобы проверить, что конкретный параметр в конкретный момент времени соответствует строковому типу данных, необходимо проверить его текущий тег,
и причем все эти сравнения проводятся для каждого растения отдельно. Помимо того, что необходимость подобных проверок замедляет работу программы, сам по себе Python - 
интерпретируемый язык, что может существенно усложнить разработку относительно больших программ, поскольку многие ошибки возможно зафиксировать лишь на этапе
выполнения программы. Лично для себя я не могу отметить никаких преимуществ использования данного подхода, но ради объективной оценки стоит отметить, что использование
модели транслятора-интерпретатора может в какой-то мере ускорить процесс внесения изменений в программу, поскольку не придется тратить время на компиляцию программы 
после каждого улучшения.